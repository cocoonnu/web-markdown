# 第一章 前端八股文

八股文和前端基础的话推荐这些专栏和网站进行学习：

- https://vue3js.cn/interview/
- https://www.codecrack.cn/zh
- https://juejin.cn/column/7243016090816905275
- https://juejin.cn/post/7023906112843808804
- https://github.com/pro-collection/interview-question



## HTML/CSS

**CSS选择器及其优先级**

- id - 属性、类、伪类 - 标签、伪元素选择器

- https://juejin.cn/post/6905539198107942919#heading-2



**CSS中可继承与不可继承属性有哪些**

- 不可继承性属性：背景、盒子模型、定位、display 等属性，继承性属性：文字、文本系列属性

- https://juejin.cn/post/6905539198107942919#heading-3



**块元素、行内元素、行内块元素的区别、display的属性值及其作用**

- https://juejin.cn/post/6905539198107942919#heading-4



**隐藏元素的方法有哪些**

- https://juejin.cn/post/6905539198107942919#heading-6



**谈谈你对 BFC 的理解**

- https://vue3js.cn/interview/css/BFC.html



**CSS 加载会造成阻塞吗**

- https://juejin.cn/post/7256702654578409532#heading-5

> CSS 阻塞主要是指外链样式表会阻塞页面渲染，因为浏览器需要等 CSS 加载完成后才能构建渲染树。这样做是为了避免出现没有样式的页面闪现。也因此我们在优化中会考虑加快 CSS 加载，比如压缩、合并、放在 <head> 提前加载等。



**重排（回流）和重绘有什么区别，什么会引发重排，什么会引发重绘**

- https://juejin.cn/post/7256702654578409532#heading-6



**为什么有时候⽤ translate 来改变位置⽽不是 position 定位**

- https://juejin.cn/post/6905539198107942919#heading-13



## Javascript

**说说 var、let、const 之间的区别**

- 变量提升、暂时性死区、重复声明、块级作用域、修改声明的变量

- https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var



**ES6中数组新增了哪些扩展**

- 扩展运算符、构造函数：Array.from()、Array.of()、实例对象方法：copyWithin()，find()、findIndex()，fill()，entries()，keys()，values()，includes()，flat()，flatMap()

- https://vue3js.cn/interview/es6/array.html#%E4%B8%80%E3%80%81%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8



**ES6 对象新增了哪些扩展**

- 属性名简写、属性名表达式、拓展运算符，关于对象新增的方法

- https://vue3js.cn/interview/es6/object.html#%E4%B8%80%E3%80%81%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99



**ES6 函数新增了哪些扩展**

- 函数参数允许设置默认值，新增箭头函数，箭头函数与普通函数的区别

- 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象
- 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误
- 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替

- https://vue3js.cn/interview/es6/function.html#%E4%B8%80%E3%80%81%E5%8F%82%E6%95%B0



**箭头函数和普通函数的区别**

- 箭头函数和普通函数最核心的区别在于 this 指向。普通函数的 this 是运行时绑定的，取决于调用方式，而箭头函数的 this 是定义时绑定的，继承自它的外层作用域。此外，箭头函数不能作为构造函数（不能 new），没有自己的 arguments 和 prototype，也不适合用作对象的方法。箭头函数更适合用在需要保留 this 的场景，比如定时器回调、事件处理、数组方法中的回调函数等。  



**介绍一下 undefined 和 null 的区别**

- 讲一下两者的定义，并且列举一下函数入参和解构赋值的时候设置默认值的例子
- https://www.codecrack.cn/zh/javascript/difference-between-undefined-and-null



**0.1 + 0.2 为什么不等于 0.3**

- 根本原因是浮点数的二进制表示，许多看似简单的十进制小数在计算机中无法精确表示，导致计算时产生微小的误差
- 一般的浮点数的比较方法为：x - y == y  就是 true，x - y == z  就是 false  
- https://www.codecrack.cn/zh/javascript/why-decimal-addition-not-equal



**介绍一下原型与原型链的概念**

- 讲解构造函数和实例的对象的关系，隐式原型和原型对象的关系，共享字段和方法还有原型链的查找等等
- https://juejin.cn/post/6844903989088092174
- https://www.codecrack.cn/zh/javascript/prototype-chain#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F

> JavaScript 是基于原型继承的语言。每个对象都有一个内部属性 [[Prototype]]（可以通过 __proto__ 访问），它指向创建它的构造函数的 prototype 属性。当访问对象的属性时，如果对象本身没有，会沿着它的原型链向上查找，直到找到为止或遇到 null。这条查找链就叫做原型链。原型链是 JS 实现继承和共享方法的基础。



**如何判定一个属性来自于对象本身， 还是来自于原型链**

- https://github.com/pro-collection/interview-question/issues/1044



**介绍一下 JavaScript 中的 new 操作符**

- https://juejin.cn/post/7244335987575521336#heading-12
- https://www.codecrack.cn/zh/javascript/prototype-chain#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0



**介绍一下浅拷贝和深拷贝的概念，并利用循环递归的方式手写深拷贝**

- https://vue3js.cn/interview/JavaScript/copy.html#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8



**什么是闭包，它的作用是什么**

- 例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期

- https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88

> 闭包是指一个函数可以访问其外部作用域中的变量，即使这个函数在外部作用域之外被调用。闭包常用于数据私有化、状态保持、延迟执行等场景。比如我们可以用闭包封装一个计数器函数，让变量在函数外部无法直接访问。需要注意的是，闭包会延长变量的生命周期，如果处理不当可能会导致内存泄漏。



**谈谈你对 this 对象的理解**

- new 绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级

- https://vue3js.cn/interview/JavaScript/this.html#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89

- 跟深入理解：https://www.codecrack.cn/zh/javascript/this-binding



**说说 JavaScript 中的事件模型**

- 原生事件模型有两种：原始事件模型、标准事件模型
- 原始事件模型只支持冒泡，实现方式为：`<input type="button" id="btn" onclick="fun1()">`
- 标准事件模型支持冒泡或者捕获，实现方式为：`addEventListener(eventType, handler, useCapture)`
- 一个事件流分为三个阶段：事件捕获阶段 - 处于目标阶段 - 事件冒泡阶段

- https://vue3js.cn/interview/JavaScript/event_Model.html



**typeof 与 instanceof 区别**

- https://vue3js.cn/interview/JavaScript/typeof_instanceof.html#%E4%B8%80%E3%80%81typeof

> - `typeof`会返回一个变量的基本类型，`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上，返回的是一个布尔值



**说一说 Javascript 本地存储的方式有哪些，区别及应用场景**

- https://vue3js.cn/interview/JavaScript/cache.html



**说说 Javascript 数字精度丢失的问题，以及如何解决**

- 计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，因为存储时有位数限制（64位），并且十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差

- https://vue3js.cn/interview/JavaScript/loss_accuracy.html



**如何判断一个元素是否在可视区域中**

- https://vue3js.cn/interview/JavaScript/visible.html



**async await 原理以及如何捕捉错误**

- https://vue3js.cn/interview/JavaScript/event_loop.html#%E4%B8%89%E3%80%81async%E4%B8%8Eawait



**JS 继承有哪些？有什么优缺点？**

- 原型链继承、构造函数继承、组合继承、使用 `Object.create` 实现浅拷贝对象、寄生组合式继承（class 语法糖采用形式）

- https://vue3js.cn/interview/JavaScript/inherit.html



**什么是变量提升和函数提升**

- https://www.cnblogs.com/liuhe688/p/5891273.html



**常量枚举和普通枚举有什么区别**

- 普通枚举 `enum A {...}` 和常量枚举 `const enum A {...}` 之间的区别主要在于 `TS` 的编译结果上有所差别

- 普通枚举 `enum A {...}`, 会将其编译为一个 `JS` 对象, **对象内就是枚举成员和值的一个相互映射**

- 常量枚举 `const enum A {...}`, 编译后不会生成任何代码, 会删除 `TS` 部分内容, 对于使用到的成员只会进行值的替换

- 由此可见, 使用 `常量枚举` 会有更好的性能, 避免额外的性能开销
- https://juejin.cn/post/7305473943572643877



**数组去重有哪些实现方法**

- 使用 lodash 里面的 uniq 或者 uniqBy：https://www.lodashjs.com/docs/lodash.uniqBy



**TS 中 interface和 type 区别**

- https://www.codecrack.cn/zh/typescript/type-and-interface-differences-in-typescript
- interface 更适合描述“对象的结构”，比如组件 props、类的类型；type 更灵活，它可以描述任意类型组合，比如联合类型、交叉类型、条件类型等。在大多数项目中，interface 和 type 是可以互补使用的。



**说一说 `==`、`===` 和 `Object.is` 的区别**

- `==`：会进行隐式类型转换

- `===`：不会隐式转换，严格类型判断。但是 `+0 === -0`、`NaN !== NaN`

- `Object.is`：解决了 `+0 === -0`、`NaN !== NaN` 的问题！更加标准化判断

- https://blog.csdn.net/MRlaochen/article/details/118557765



**什么是显式类型转换和隐式类型转换**

- 学习文档里面有，复习顺序是显式类型转换->运算符->隐式类型转换
- 简单文档：https://vue3js.cn/interview/JavaScript/type_conversion.html



## React 生态

**React 合成事件是什么**

- React 基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，这套事件机制被称之为合成事件，目的是为了更好的兼容性和跨平台、减少内存开销
- React 上注册的事件最终会绑定在 document 这个 DOM 上，而不是 React 组件对应的 DOM

- https://juejin.cn/post/7250357906712838205#heading-14



**有哪些常见的 React Hooks**

- https://vue3js.cn/interview/React/React%20Hooks.html



**谈谈 MVVM 架构**

- https://juejin.cn/post/7250012486992511033#heading-6



**说一下 Reac 生命周期是怎样的**

- https://juejin.cn/post/7250357906712838205#heading-0

> 创建阶段：constructor、render、componentDidMount；更新阶段：shouldComponentUpdate、render、componentDidUpdate；卸载阶段：componentWillUnmount



**虚拟 DOM 实现原理，如何理解**

- https://juejin.cn/post/7250012486992511033#heading-22

> React 在渲染页面的时候，不是直接操作真实的 DOM，而是先在内存里创建一个**JS对象结构**，也就是“虚拟 DOM”。当组件的状态或数据发生变化时，React 会重新生成一份新的虚拟 DOM，并把它跟旧的那份做对比（也就是 Diff），找出需要变更的地方，然后**只更新有差异的部分到真实 DOM 上**。所以我觉得虚拟 DOM 更像是 React 提供的一个“中间层”，帮我们做了性能优化，也提升了开发效率。



**介绍一下 Rudex 的工作流程**

- https://juejin.cn/post/7250357906712838205#heading-10



**描述一下 React 中的 Diff 算法**

- https://juejin.cn/post/7229598397250109497

> React 中的 Diff 算法是用于比较**虚拟 DOM 前后差异**，从而**高效更新真实 DOM** 的核心机制。它的目标是在尽可能少的操作下，将 UI 从旧状态更新到新状态。React 的 Diff 算法采用**分层对比 +关键假设优化**的方式，主要比较同一层级的虚拟 DOM 节点，通过“key”标识快速识别节点复用、移动或删除。它不会进行跨层级比较，而是逐层遍历，避免全树对比的性能开销。
>
> - **只对比同层节点**：减少比较复杂度，从 O(n³) 降低到 O(n)。
> - **通过 key 提高识别准确性**：识别节点是否可以复用或需要重建。
> - **组件类型不同直接销毁重建**：类型一致才继续比较子元素。



**说说对 Fiber 架构的理解，解决了什么问题**

- https://vue3js.cn/interview/React/Fiber.html
- https://juejin.cn/post/7229552637229498405

> 在 React 16 之前，React 使用的是递归方式构建虚拟 DOM 树（VDOM），整个更新过程是**同步的、不可中断的**。它的核心思想是把整个渲染流程拆成一个个可中断、可恢复的小任务（Fiber 节点），并通过调度器控制任务执行顺序和优先级。这样 React 就可以在合适的时机暂停当前渲染任务，转而处理用户输入或高优操作，从而提升交互的流畅度



**React 列表渲染为什么要设置 key，为什么不建议用 index 作为 key**

- https://juejin.cn/post/7250012486992511033#heading-26

> 设置正确的 key 可以帮助 React：更准确地识别哪些元素被复用、添加或删除；避免不必要的 DOM 更新，提升性能；保证组件状态（如表单输入、动画）在重新渲染时不会错乱。
>
> 虽然使用 index 可以避免报错，但它会在以下场景中导致 **渲染异常或性能问题**：
>
> 1. **数据顺序会变动**时（如插入、删除、拖拽），index 会变化，导致：组件状态丢失或错位、DOM 被错误复用或销毁
> 2. **Diff 无法正确对比新旧节点**，每次渲染都可能误判为“不同节点”，造成全量更新；
> 3. 对于带有输入框、动画或内部状态的组件，index 作为 key 会让 React 无法正确保留之前的组件状态。



**React Hooks 原理以及核心是什么**

- https://juejin.cn/post/7250357906712838205#heading-15



**React 中组件之间如何通信**

- https://vue3js.cn/interview/React/communication.html



**说说对 React 中类组件和函数组件的区别**

- https://vue3js.cn/interview/React/class_function%20component.html



**说说对高阶组件的理解和它的应用场景**

- 把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用

- 所以，高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用

- https://vue3js.cn/interview/React/High%20order%20components.html



**说说你是如何提高组件的渲染效率的**

- 父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染

- https://vue3js.cn/interview/React/improve_render.html



**双向数据绑定是什么，如何简单的手动实现**

- 先讲一遍 MVVM 架构，再讲一下 Vue 是如何实现双向数据绑定的，手写双向数据绑定的原理

- https://vue3js.cn/interview/vue/bind.html



**React 中 setState 到底是异步还是同步**

- 合成事件和生命周期里，setState 是异步的（因为 React 批量更新优化，等事件执行完后再更新）

- 原生事件 和 setTimeout 里，setState 是同步的（没有批量更新）

- 需要最新的 state，用 prevState 回调

- https://juejin.cn/post/7250357906712838205#heading-3



**React18 有什么新特性**

- React 并发模式是 React 引入的一项核心机制，主要是为了提升复杂应用中的性能和用户体验。传统的 React 渲染是同步阻塞的，一旦开始更新组件树，整个过程就无法中断，遇到一些长耗时渲染或状态更新时，容易出现页面卡顿、响应迟钝的问题。

- 我们可以使用 `useTransition` 这个 hooks，设置优先级机制让更紧急的用户操作（比如输入、点击）可以优先处理，而不被低优先级的 UI 更新阻塞。配合 `startTransition` 就能将一些非紧急的更新标记为低优先级，让 React 保证界面交互始终流畅。
- React 18 提供了 `flushSync` 方法，可以强制执行 setState 同步更新，但使用 `flushSync` 可能会对性能产生影响，并且应谨慎使用，以避免阻塞主线程。
- `createRoot` 是一个新的入口函数，用于创建根 React 组件。它可以替代原先的 `ReactDOM.render` 方法，使得开发者可以将多个根节点渲染到一个页面上。

- https://juejin.cn/post/7290815534207189033



**SPA首屏加载速度慢的怎么解决**

- https://vue3js.cn/interview/vue/first_page_time.html



**SSR 解决了什么问题，有做过 SSR 吗**

- https://vue3js.cn/interview/vue/ssr.html



## 前端工程化





## 其他技术栈
**垃圾回收机制是什么，哪些情况会导致内存泄漏**

- https://juejin.cn/post/7244335987575521336#heading-26



**什么是 CSRF 攻击**

- https://juejin.cn/post/7256702654578409532#heading-0



**进程与线程的概念**

- 进程是操作系统对一个正在运行的程序的抽象表示，负责管理程序的执行和资源分配，它存在堆内存分配和栈内存分配
- 在操作系统中，每个进程都有自己的地址空间、状态和控制信息。进程可以独立运行，与其他进程离开来，互不干扰

- 线程是进程中的一个执行路径，是进程的组成部分，**在同一个进程中的多个线程共享进程的资源，并且并行执行**
- 每个进程至少包含一个主线程，主线程用于执行进程的主要业务逻辑，其他线程可以作为辅助线程来完成特定的任务

- https://www.codecrack.cn/zh/javascript/event-loop#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B



**介绍一下浏览器的渲染过程**

- Chrome 浏览器通过多进程的架构设计来加载多个网页，主要包括以下三个进程：网络进程、浏览器进程、渲染进程
- 浏览器给渲染进程采用了多线程，它主要包含了以下线程：渲染主线程、合成线程、网络线程、定时器线程、事件处理线程
- 渲染主线程负责解析 `HTML`、`CSS` 和 `JavaScript`，构建 `DOM` 树、`CSSOM` 树和渲染树，并进行页面布局和绘制，它还处理用户交互，执行 `JavaScript` 代码以及其他页面渲染相关的任务

- http://codecrack.cn/zh/javascript/event-loop#%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84



**说说你对浏览器事件循环的理解**

- 首先 JavaScript 是一门单线程语言，当渲染主线程执行一些 JavaScript 中的**事件处理、定时器和异步操作**等异步任务时，为了防止主线程阻塞，主线程会和其他线程通过消息队列进行通信来防止阻塞

- 比如当渲染主线程正在执行一个 `JavaScript` 函数，执行到一半的时候碰到了一个定时器，也就是 `setTimeout`。因为在我们的渲染进程里面是有定时器线程的，定时器线程监听到有这个定时器操作。**那么该线程会将 `setTimeout` 里面的回调函数作为一个异步任务放入消息队列中进行排队**

- 因此事件循环就是首先执行完成**主线程的同步任务**，再依次执行**消息队列中的异步任务**，如果在异步任务里面再碰到异步任务，那么按照前面的步骤依此循环，直到所有任务执行完成

- 同步任务：变量和函数的声明和计算、普通函数调用、DOM 操作、for / while / if / switch 等语句

- 异步任务：定时器相关、I/O 相关、事件监听、Promise 等语句 

- http://codecrack.cn/zh/javascript/event-loop#%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84

> 浏览器的事件循环机制是 JavaScript 实现异步非阻塞的重要基础。由于 JavaScript 是单线程的，它会把所有的同步任务先执行完，然后再处理异步任务。异步任务被分为宏任务和微任务，比如 setTimeout 属于宏任务，而 Promise.then 属于微任务。在一次事件循环中，主线程会先执行一个宏任务，然后清空这个过程中新产生的所有微任务，再进入下一个宏任务。



**Node.js 事件循环机制和浏览器的有什么不同**

- 先介绍 Nodejs 的事件循环机制的理解，再介绍具体的区别
- 区别一：process.nextTick 是 Node.js 中用于注册比其他所有异步任务还早执行的微任务
- 区别二：Nodejs 的事件循环分成多个阶段（timers, poll, check 等）
- 区别三：Node.js 借助 libuv 实现复杂事件循环
- https://vue3js.cn/interview/NodeJS/event_loop.html

> 相比之下，Node.js 中的事件循环更复杂一些，会有多个阶段和更高优先级的 process.nextTick。但核心原理类似，都是围绕宏任务与微任务的调度来实现异步执行的。



**谈谈你对异步的理解，并讲一下什么是宏任务和微任务**

- 最简单的理解异步：`JavaScript` 是一门单线程的编程语言，意味着在一个特定的时间点，只能有一个代码块在执行。当执行一个同步任务时，如果任务需要很长时间才能完成，如网络请求、文件读取等，整个程序会被阻塞，导致用户界面无响应，甚至造成卡顿的问题。而异步编程使得我们可以在主线程执行同步代码的同时，处理耗时的异步操作，例如网络请求、文件读写等，以提高程序的性能和用户体验。在 `JavaScript` 中，通过事件循环机制，异步编程实现了一种非阻塞的执行方式，使得浏览器能够高效地处理各种任务，同时保持用户界面的响应性
- 上一个问题我们讲到异步任务存储于消息队列中，消**息队列又分为宏任务队列和微任务队列。**微任务通常在一个宏任务执行完毕后立即执行，而不需要等待其他宏任务，这使得微任务的执行优先级比宏任务高
- 宏任务：setTimeout 和 setInterval、I/O 操作、DOM 事件、requestAnimationFrame、**script 标签**
- 微任务：Promise 的 resolve 和 reject 回调、async/await 中的异步函数、MutationObserver
- 由于 script 标签是一个宏任务，因此整个浏览器循环应该是 先执行 `宏任务` -> `同步代码` -> `微任务`，直到当前宏任务中的微任务清理完毕，继续执行下一个宏任务，以此类推
- https://www.codecrack.cn/zh/javascript/event-loop#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5



**说说地址栏输入 URL 敲下回车后发生了什么**

- URL 解析、DNS 查询、TCP 连接、HTTP 请求、响应请求、响应资源解析、页面渲染

- https://vue3js.cn/interview/http/after_url.html

- 超详细版文档：https://juejin.cn/post/7316775422187061300



**对浏览器的缓存机制的理解？强缓存和协商缓存？**

- https://juejin.cn/post/7256702654578409532#heading-3



**说说 TCP 为什么需要三次握手和四次挥手**

- https://vue3js.cn/interview/http/handshakes_waves.html



**说说 HTTP 常见的状态码有哪些，适用场景**

- https://vue3js.cn/interview/http/status.html



**什么是同源策略**

- 同源策略是一种规定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略浏览器的安全功能将会受到影响。所谓同源是指：域名、协议、端口相同，同源策略又分为以下两种：XMLHttpRequest 同源策略、DOM 同源策略

- https://juejin.cn/post/7256702654578409532#heading-9



**如何解决跨域问题**

- CORS：跨域资源共享，只要服务端添加一个 `Access-Control-Allow-Origin` 请求头设置为我们的目标域名，这个 HTTP 头就决定浏览器允许我们获取跨域请求的响应

- JSONP：它的原理就是利用 `<script>` 标签没有跨域限制，通过 `<script>` 标签 src 属性，发送带有 `callback` 函数的 **GET请求**，服务端将接口返回数据拼凑到 `callback` 函数中，返回给浏览器，从而前端再利用 `callback` 函数拿到返回的数据

- Proxy：网络代理模式，有以下几种解决方案：1. 我们可以通过 `webpack` 为我们起一个本地服务器作为请求的代理对象，通过该服务器转发请求至目标服务器，得到结果再转发给前端 2. 此外还可通过一些 node 服务端比如 express 实现代理请求转发 3. 最后是直接可以在服务器上配置 Nginx 实现反向代理从而实现跨域

- https://juejin.cn/post/7256702654578409532#heading-10

- https://vue3js.cn/interview/vue/cors.html



**git rebase 和 git merge 的区别是什么**

- https://juejin.cn/post/7257441472458604599#heading-7



## 算法与手写

今天的手写题主要参考：https://juejin.cn/post/7023906112843808804#heading-0

- 手写 new 操作符

- 手写科里化函数
- 使用setTimeout构建setInterval
- 手写instanceof
- 实现一个LRU缓存函数，可获取数据和写入数据，如果数据量超出时则删除最久未使用的数据值



今天的手写题主要参考：https://juejin.cn/post/7023906112843808804#heading-13

- 简单实现 发布订阅模式
- 实现 JSON.parse
- 递归循环实现基础的深拷贝：https://vue3js.cn/interview/JavaScript/copy.html
- 手写防抖和节流
- 手写数组去重
- 手写 call、apply
- 手写 bind，既要实现改变指向又要兼容构造函数



今天的手写题主要参考：https://juejin.cn/post/6994594642280857630

- 手写 Promise，实现基本 Promise 回调与 then 链式调用
- 手写 Promise.all
- 手写 Promise.race
- 手写 Promise.allSettled



# 第二章 简历面试题

## 专业技能栏

**有没有 NextJs+Tailwind 项目实战经验**

我有学习并实际使用过 Next.js 和 Tailwind CSS，虽然还没有参与正式上线的项目，但自己通过文档和一些 demo 项目熟悉了它们的用法。比如在 Next.js 里我了解了它的页面路由机制、getServerSideProps 数据预取、静态生成等渲染方式；也尝试用 Tailwind 搭配组件开发，实现响应式布局、主题切换等常见 UI。我觉得 Tailwind 搭配 Next.js 开发体验非常流畅，尤其是在做官网、个人组件库、博客类页面等场景时能快速上线。如果后续工作中有这类技术的需求，我能很快上手，并愿意投入更多实际项目来加深理解。



**你了解 Next.js 的服务端渲染是如何实现的吗？它的优缺点分别是什么？**

Next.js 的 SSR 是通过在服务端预先生成 HTML 页面并返回给客户端实现的，核心是 getServerSideProps 这个生命周期钩子。服务端收到请求后先取数据，再和组件一起渲染成 HTML，最后发送给浏览器。优点是首屏渲染更快、更有利于 SEO；缺点是服务器压力更大，接口响应慢会影响首屏体验，也不利于缓存。在我项目中，如果数据是用户私有的、变化频繁的场景，我们会使用 SSR；但对于可缓存的静态内容，会选择 SSG 或 CSR。



**Tailwind CSS 的原子化 CSS 和传统 CSS 有什么区别**

Tailwind 的原子化 CSS 是一种“类即样式”的方式，每个 className 都对应一个具体的样式声明，和传统的 BEM、CSS Modules 相比，它鼓励直接在 HTML 或 JSX 中组合多个样式类。优势是开发效率高、样式一致性好、避免命名冲突，适合团队协作；劣势是初期类名看起来比较冗长、不够语义化，对新手不太友好。在我使用 Tailwind 的项目中，我搭配了 VSCode 插件做类名提示，配合组件抽象来保持代码整洁，实际开发体验还是非常流畅的。



**Webpack 和 Vite 有哪些核心区别**

Webpack 和 Vite 的最大区别在于构建方式：

- Webpack 是基于打包（bundle）的开发模型，所有模块构建完才能运行；
- Vite 是基于原生 ES 模块的按需加载，开发阶段利用浏览器原生支持 + esbuild 实现快速启动和热更新。

我觉得在大型项目中，Webpack 插件生态更强，适合高度定制；而 Vite 更轻量，开发体验很好，适合快速原型或中小型项目。

我在学习过程中也尝试配置过它们的别名、CSS 预处理器、静态资源处理等基础配置，能应对一般项目需求。



**说一下如何快速搭建一个 Node 服务**

我通常会使用 Express 框架来快速搭建一个 Node.js 服务器，整个流程大致分为几个步骤：首先，通过 `npm init` 初始化项目，再安装 `express` 包。接着，在入口文件中引入 Express，创建 app 实例，并配置必要的中间件，比如 `express.json()` 用于解析 JSON 请求体。然后，通过 `app.get()` 或 `app.post()` 定义基本的接口路由，比如返回字符串或接收前端提交的数据。最后，使用 `app.listen()` 启动服务器并监听端口，比如 3000，这样就可以在浏览器或  Postman 中访问接口了。整体流程简单，十几行代码就能完成一个基础服务，适合用于 mock 数据、本地联调或前后端解耦的中间层。如需拓展，也可以说明支持跨域配置、路由模块化、错误处理等常见实践。



## 工作经历栏

**你在这个微前端项目中负责了哪些内容？是如何实现主子应用的解耦接入的？**

我在上家公司主要负责他们一个政务协同平台的开发，该平台包括组织架构、勤务管理、IM 通信、数据元等核心模块，我们都基于一个主应用的基础上，结合微前端技术将这些核心模块作为子应用进行接入，微前端使用的是 qiankun 框架，本质上还是使用 iframe 引入一个个子页面，主子应用通信大致是基于公司内部封装好的一个跨域通信 iframe 组件，向子应用注入了一些通信方法，比如新建删除子应用、获取主应用发过来的数据、向指定应用发送数据和监听触发事件等等。我在前期主要负责在应用层去熟悉和使用，后期我也开始慢慢接触微前端通信的一些核心代码，也开始维护和拓展一些新的功能，让微前端使用起来根据高效便利。



**你是怎么基于 useBridge 优化主子系统通信的？**

我刚进团队的时候，在项目老的代码里主子应用通信还是基于 props 和监听事件的方式来进行的，这种方式容易出现状态同步滞后、事件耦合度高、维护复杂等问题。后面团队基于现有的通信机制封装了一个自定义 hook，叫做 useBridge。这个 hook 本质上是对通信协议的抽象封装，统一了主对子、子对主的事件触发和数据传递方式，**并将通信逻辑从组件内部剥离**，提升了复用性和可维护性。它提供了对 应用新增删除操作、事件触发、状态传递、消息监听等功能的统一调用方式。我也参与过方案设计和落地，目前已被复用到多个业务模块中，提升了团队在微前端下的系统整合效率。



**你是如何基于 ECharts 实现复杂数据可视化的？有哪些定制的地方？**

使用了 option 的灵活配置能力，实现了多种图表（如柱状图、折线图、饼图等）动态切换；对 tooltip、legend、axis label 等做了样式定制与数据格式处理；在数据量大时，采用了懒加载 + 虚拟滚动等优化策略，提升渲染性能。



## 项目经历栏

**你是怎么实现拖拽排序的**

在我的问卷系统里，我使用的是 **DnDKit** 来实现拖拽排序。它比较轻量、灵活，API 也比较现代，具体实现方式是这样的：我首先用 DndContext 包裹整个拖拽区域；用 SortableContext 包裹需要排序的选项列表，并传入它们的唯一 key；另外会封装一个通用的选项组件 SortableItem，使得每个选项组件内部使用 useSortable，这个 Hook 会帮我处理拖拽事件和样式；当拖拽结束时，会触发 onDragEnd 回调，我会在这里判断拖拽前后的顺序变化，然后用 arrayMove 方法来更新数据顺序。



**你的路由懒加载是如何实现的？用到了什么技术？**

我是通过封装 React 的 lazy 和 Suspense 来实现路由组件的懒加载。具体来说：在路由系统中首先用 React.lazy 包装动态 import 的路由组件；然后再用 Suspense 包裹来实现异步加载；另外将整体封装成一个 LazyComponent 工具函数，支持传入自定义的 loading 组件或错误处理。



**你们的全局弹窗管理是怎么实现的？**

我封装了一个全局的弹窗管理器，在 mian 代码里使用了一个全局事件总线（app.watch / app.emit），本质是自定义的发布订阅机制；所有弹窗都通过全局的弹窗管理器管理并监听事件；`app.emit('@@:open:layer', key, props, isSingle)`



# 第三章 非技术面

## 自我介绍

您好，我叫陈智毅，23岁，毕业于东华理工大学，目前有两年前端开发经验，主要使用 React 技术栈；我是从22年开始学习前端的，23年开始实习，实习的时候主要参与电子会计档案管理平台建设，一个 toB 的中后台管理系统；24年毕业后来杭州这边参加工作，工作中我主要负责公司自研的综合协同平台“公务云”项目的前端开发，平台覆盖组织架构、勤务管理、IM 通信、数据元等核心模块，业务上于钉钉有点类似，该平台目前只作为集团内部使用；个人项目的话有一个全栈的问卷系统，同时我也写技术笔记和规划任务的习惯，目前希望加入一个技术氛围浓厚的团队，继续在前端架构、低代码、工程化方向深入发展。



## 非技术问题

**为什么从当前这家公司离职**

目前的这份工作让我在项目协作和业务理解上有了一定积累，但在技术成长上我逐渐感到瓶颈，比如缺乏系统性提升的机会、项目挑战性也相对有限。所以我这次是希望能加入一家更具技术深度的团队，接触更规范的开发流程或复杂项目，在解决问题的过程中不断成长。我也希望能够在这家公司长期发展，从一开始就树立晋升意识，随着经验积累在技术能力和薪酬待遇上都实现正向成长。



**你认为自己相比同龄前端工程师的优势在哪里**

一是性格沉稳、有耐心、有责任心，遇到问题不会慌，能冷静分析、一步步解决遇到的问题和难点。二是我有整理和反思的习惯，平时会写技术笔记，也喜欢把一些项目经验总结成文档，这让我对知识掌握得更系统，也能更快地在新项目中上手。三是做事比较有条理，拿到任务会先规划，不会一上来就写代码，而是先想清楚实现方案、注意点、可能的坑，工作推进效率还不错。还有一点是专注力比较强，我能静下心来去看项目代码或者学习新东西，哪怕任务比较复杂或者逻辑很绕，也能沉下去一点点理清楚。



**你在技术方面对于未来有什么规划？**

未来我主要想在三个方向上继续深入。

第一是低代码平台建设，我之前在项目中接触过一些配置驱动、动态表单这类能力，也意识到低代码在提升交付效率、规范业务逻辑方面的价值，后续希望能参与更体系化的低代码平台开发，比如搭建可视化编辑器、规则引擎、权限控制这些核心模块。

第二是 AI 与前端的结合，这块我也在持续关注，比如在开发辅助工具、页面生成、智能表单推荐等方向的探索，未来如果有机会，我希望能参与前端与 AI 结合的一些实际场景落地，提升用户体验或者开发效率。

第三是前端工程化，这一直是我比较关注的方向。像打包优化、CI/CD、代码规范、组件库建设这些我都有一定经验，也希望在更大体量的项目中不断积累，参与团队工程体系的搭建和优化。

这三个方向我都挺有兴趣的，也觉得都是未来前端发展的关键领域。



**你在工作中遇到的难点和挑战是什么**

我印象比较深的一次挑战是在刚加入公司不久时，参与了公务云项目中的一个紧急需求开发。当时的背景是这个功能有上线时间要求，留给开发的时间非常紧，而且需求本身也比较复杂，需要实现一个表格嵌套动态表单的交互效果，字段是动态生成的，还涉及校验、回填、联动等行为。

我是独立负责这个模块的，当时我做的第一件事就是冷静整理思路，把整个功能拆分成几个阶段来推进，比如先把表格结构和数据模型搭建好，再一块块去处理表单渲染、动态字段配置、交互逻辑等；同时我也参考了项目中类似的实现逻辑，尽量复用已有能力来提高开发效率。因为时间紧张，我对每一步都提前做了预判，尽可能避免返工，开发过程中也保持了频繁的自测，确保交付质量。

最后我在 deadline 前按时提测，测试阶段也没有出现严重 bug，修复一些小问题后顺利上线。这是我入职后第一个完整独立完成的模块，对我来说挑战挺大的，但也让我快速熟悉了业务逻辑和项目框架，也提升了自己规划和独立解决问题的能力。



**为什么选择前端这条路**

一开始接触前端是因为我对交互和页面视觉挺感兴趣的，能通过代码把一个个设计图变成可交互的产品，这种成就感对我很有吸引力。

后来真正参与项目后，我发现前端不仅仅是“做界面”，它在整个平台里承担着连接用户和系统的桥梁，涉及到状态管理、权限控制、工程化、甚至平台架构等，这让我意识到前端其实也有很深的技术积累空间。

我自己也比较喜欢整理思路、研究交互细节，再加上我性格上比较有耐心，适合处理前端这种既需要逻辑也需要细节打磨的工作。长期来看，我也希望能在前端架构、低代码、工程体系这些方向不断提升，做出能支撑业务长期演进的前端能力。

所以综合考虑后，我选择了前端这条路，并且也希望长期深耕下去。



**平时是如何学习前端的**

平时我比较注重主动学习和思考总结，除了工作中的实际项目积累，我也有写技术笔记的习惯，比如用 Typora 记录一些组件封装、业务逻辑分析、源码阅读笔记等，帮助自己形成体系。

我喜欢带着问题去学习，比如在遇到复杂交互或性能瓶颈时，会去查相关原理，看看社区有没有更好的方案，同时也会关注一些高质量的前端博客、技术专栏，跟进一些框架或工程化工具的演进。

另外，我也会定期回顾项目中遇到的问题，从中总结通用的解决思路，比如提取成通用组件、编写工具函数，提升自己的复用和抽象能力。整体来说，我的学习方式偏实践驱动，遇到问题就深入挖，解决之后再整理沉淀，这样学到的东西更容易转化为自己的能力。



**为什么来杭州发展**

杭州这边互联网公司多，技术氛围好，对前端来说机会也多，而且我现在就在杭州工作，整体也比较适应，后面也希望长期在这边扎根发展。



**你是如何处理压力和挑战的**

我处理压力的方式是先把问题拆解清楚、排好优先级，不会盲目硬扛。遇到挑战我会主动去分析解决路径，过程中也会通过写笔记或阶段性总结来保持清晰的思路，尽可能把压力转化成推动力。



## 个人反问

- 公司联勤制度、工资发放制度、请假制度、有哪些福利等等
- 后面的面试流程大概是怎么样的，预计什么时候能确定结果
- 目前公司的需要业务是什么
- 前端开发的话主要的工作内容是什么
- 一个项目的周期大概是多久
- 前端项目用的是哪些技术栈



# 第四章 面试记录

**大智慧（1000-9999）技术一面**

```ts
node事件循环机制和浏览器有什么不同  
数组去重有哪些实现方法  
判断一个对象（直接判断内部的值）是否相等  
react 的useMemo和useCallback传入多个依赖变量应该如何进行性能优化  
React18有什么新特性  
fiber 渲染机制，什么中断机制的概念  
interface和type区别  
antd按需加载如何实现  
ES6有哪些新特性  
高阶函数是什么，有什么作用和缺点  
遍历数组和对象的方式有哪些  
Object.keys()和forin循环遍历对象有什么区别  
路由拦截器怎么实现的  
```



**大智慧（1000-9999）技术二面**

```js
为什么选择前端  
平时是如何学习前端的  
React和Vue有什么区别  
为什么选择来合肥  
在实习期间最有挑战性的事情是什么  
在做项目期间有哪些性能优化的点  
白屏时间长应该怎么解决  
项目里的权限管理有哪些，如何实现的  
有参与项目的组件封装吗  
useMemo和useCallback有什么区别  
拖拽排序是如何实现的  
受控组件和非受控组件的区别  
什么是虚拟dom  
```



**半糖科技（100-499）技术一面**

```js
什么是BFC  
有了解过React18吗  
有搭建过webpack的其他配置吗  
能不能从0开始搭建一套webpack工程化  
CSS阻塞是什么情况  
箭头函数和普通函数的区别  
如何手动实现一个虚拟列表  
什么是宏任务和微任务  
普通函数中的this指向问题  
原型链的概念  
forof和forin的区别  
如何使得forof可以遍历一个对象  
什么是迭代对象，底层原理是什么  
迭代器和迭代对象有什么区别，如何实现迭代器  
什么是事件委托  
React的fiber机制是什么  
React的合成事件是什么  
URL从输入到页面渲染经历了哪些过程  
如何实现拖拽排序，底层原理是什么，哪些html标签支持拖拽  
什么是同源策略  
什么是回流和重绘  
什么是浏览器的缓存机制  
当我们要进行一个元素的位移，使用移动更好还是定位更好，为什么  
Vue中的data返回的为什么是一个函数而不是对象  
SSR是什么，有什么哪些方面的优点  
在实习过程中有没有遇到什么难点  
```



**玩点科技（100-499）技术一面**

```md
全是照着简历问的
项目中的虚拟列表是怎么实现的
项目中的登录拦截器是怎么实现得到
了解哪些浏览器存储
介绍一下promise
介绍一下flex
说一下八种数据结构
说一下如何快速搭建一个node服务器吧
你是如何实现项目中的全局弹窗管理的
```



